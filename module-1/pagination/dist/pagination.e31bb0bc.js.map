{"version":3,"sources":["index.js"],"names":["data","settings","actualPageIdx","entriesOnPage","paginateArray","dataEntries","paginateSettings","isArray","Array","Error","numberOfPages","length","Math","floor","console","log","isInteger","Number","isPositiveNumbers","isCorrectActualPageIndex","dataEntriesCopy","entriesOnSelectedPage","i","push","slice","result"],"mappings":";;;;;;;;;;;;AAAA;AACA;AAEA;AACA,IAAMA,IAAI,GAAG,CAAC,CAAD,EAAG,CAAH,EAAK,CAAL,EAAO,CAAP,EAAS,CAAT,EAAW,CAAX,EAAa,CAAb,EAAe,CAAf,EAAiB,CAAjB,EAAmB,EAAnB,CAAb;AACA,IAAMC,QAAQ,GAAG;AAAEC,EAAAA,aAAa,EAAE,CAAjB;AAAoBC,EAAAA,aAAa,EAAE;AAAnC,CAAjB;;AAEA,IAAMC,aAAa,GAAG,SAAhBA,aAAgB,CAACC,WAAD,EAAcC,gBAAd,EAAmC;AACvD,MAAMC,OAAO,GAAGC,KAAK,CAACD,OAAN,CAAcF,WAAd,CAAhB;AACA,MAAG,CAACE,OAAJ,EAAa,MAAM,IAAIE,KAAJ,CAAU,0CAAV,CAAN;AAEb,MAAOP,aAAP,GAAuCI,gBAAvC,CAAOJ,aAAP;AAAA,MAAsBC,aAAtB,GAAuCG,gBAAvC,CAAsBH,aAAtB;AACA,MAAMO,aAAa,GAAGL,WAAW,CAACM,MAAZ,GAAqBR,aAArB,KAAuC,CAAvC,GACAS,IAAI,CAACC,KAAL,CAAWR,WAAW,CAACM,MAAZ,GAAqBR,aAAhC,CADA,GAEAS,IAAI,CAACC,KAAL,CAAWR,WAAW,CAACM,MAAZ,GAAqBR,aAAhC,IAAiD,CAFvE;AAGAW,EAAAA,OAAO,CAACC,GAAR,CAAYL,aAAZ;AAEA,MAAMM,SAAS,GAAGC,MAAM,CAACD,SAAP,CAAiBd,aAAjB,KAAmCe,MAAM,CAACD,SAAP,CAAiBb,aAAjB,CAArD;AACA,MAAG,CAACa,SAAJ,EAAe,MAAM,IAAIP,KAAJ,CAAU,wDAAV,CAAN;AAEf,MAAMS,iBAAiB,GAAGhB,aAAa,IAAI,CAAjB,IAAsBC,aAAa,IAAI,CAAjE;AACA,MAAG,CAACe,iBAAJ,EAAuB,MAAM,IAAIT,KAAJ,CAAU,+DAAV,CAAN;AAEvB,MAAMU,wBAAwB,GAAGjB,aAAa,GAAGQ,aAAjD;AACA,MAAG,CAACS,wBAAJ,EAA8B,MAAM,IAAIV,KAAJ,CAAU,8BAAV,CAAN;;AAE9B,MAAMW,eAAe,sBAAOf,WAAP,CAArB;;AACA,MAAMgB,qBAAqB,GAAG,EAA9B;;AAEA,OAAI,IAAIC,CAAC,GAAG,CAAZ,EAAeF,eAAe,CAACT,MAAhB,GAAyBW,CAAxC,EAA2CA,CAAC,IAAInB,aAAhD,EAA+D;AAC7DkB,IAAAA,qBAAqB,CAACE,IAAtB,CAA2BH,eAAe,CAACI,KAAhB,CAAsBF,CAAtB,EAAyBA,CAAC,GAAGnB,aAA7B,CAA3B;AACD;;AAED,SAAOkB,qBAAqB,CAACnB,aAAD,CAA5B;AACD,CA3BD;;AA6BA,IAAMuB,MAAM,GAAGrB,aAAa,CAACJ,IAAD,EAAOC,QAAP,CAA5B,EACA;;AACAa,OAAO,CAACC,GAAR,CAAYU,MAAZ","file":"pagination.e31bb0bc.js","sourceRoot":"..","sourcesContent":["// actualPageIdx to index wybranej strony (indexujemy od 0)\n// entriesOnPage to maksymalna zwracana ilość elementów z dataEntries dla wybranej strony\n\n// przykładowe dane\nconst data = [1,2,3,4,5,6,7,8,9,10];\nconst settings = { actualPageIdx: 2, entriesOnPage: 4 };\n\nconst paginateArray = (dataEntries, paginateSettings) => {\n  const isArray = Array.isArray(dataEntries);\n  if(!isArray) throw new Error('Argument dataEntries have to ba an array');\n\n  const {actualPageIdx, entriesOnPage} = paginateSettings;\n  const numberOfPages = dataEntries.length % entriesOnPage === 0 ?\n                        Math.floor(dataEntries.length / entriesOnPage) :\n                        Math.floor(dataEntries.length / entriesOnPage) + 1;\n  console.log(numberOfPages);\n\n  const isInteger = Number.isInteger(actualPageIdx) && Number.isInteger(entriesOnPage);\n  if(!isInteger) throw new Error('actualPageIndex and entriesOnPage have to be a integer');\n\n  const isPositiveNumbers = actualPageIdx >= 0 && entriesOnPage >= 0;\n  if(!isPositiveNumbers) throw new Error('actualPageIndex and entriesOnPage cannot be a negative number');\n\n  const isCorrectActualPageIndex = actualPageIdx < numberOfPages;\n  if(!isCorrectActualPageIndex) throw new Error('Selected page does not exist');\n\n  const dataEntriesCopy = [...dataEntries];\n  const entriesOnSelectedPage = [];\n\n  for(let i = 0; dataEntriesCopy.length > i; i += entriesOnPage) {\n    entriesOnSelectedPage.push(dataEntriesCopy.slice(i, i + entriesOnPage));\n  }\n\n  return entriesOnSelectedPage[actualPageIdx];\n};\n\nconst result = paginateArray(data, settings);\n// result === [3,4]\nconsole.log(result);\n"]}